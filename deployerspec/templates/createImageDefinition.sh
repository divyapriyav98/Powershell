#!/bin/bash
set -euo pipefail

# ============================================================
# Image Definition Creation Script (argument-driven)
# Expects metadata variables prepared (e.g. by createImageDefinition_prep.sh)
# or provided directly via arguments / env file.
# ============================================================

show_usage() {
  cat <<'EOF'
Usage: createImageDefinition.sh \
  --target-subscription <subId> \
  --target-rg <rgName> \
  --target-gallery-name <galleryName> \
  --target-location <location> \
  --image-definition-name <name> \
  --publisher <publisher> --offer <offer> --sku <sku> \
  --os-type <Linux|Windows> --os-state <Generalized|Specialized> \
  --hyper-v-generation <V1|V2> \
  [--description <text>] [--eula <url>] [--privacy-uri <url>] [--release-note-uri <url>] \
  [--end-of-life <YYYY-MM-DD>] [--tags 'k1=v1 k2=v2'] \
  [--plan-name <name>] [--plan-product <product>] [--plan-publisher <publisher>] \
  [--disallowed-disk-types 'Premium_LRS,StandardSSD_LRS'] \
  [--architecture <Arch>] \
  [--accelerated-networking true|false] [--automatic-os-upgrade true|false] \
  [--rec-vcpus-min <n>] [--rec-vcpus-max <n>] \
  [--rec-mem-min <GB>] [--rec-mem-max <GB>] \
  [--features 'Name=Value Name2=Value2'] \
  [--env-file <fileProducedByPrep>] \
  [--dry-run] \
  [-h|--help]

You may supply an --env-file generated by createImageDefinition_prep.sh which already
contains all exported variables; arguments passed after --env-file override those values.

Environment variables with the same names still act as defaults if neither env file nor
arguments provide them.

Idempotent: skips creation if the image definition already exists.

EOF
}

# -------- Initialize from environment (defaults) --------
TARGET_SUBSCRIPTION="${TARGET_SUBSCRIPTION:-}"
TARGET_RG="${TARGET_RG:-}"
TARGET_GALLERY_NAME="${TARGET_GALLERY_NAME:-}"
TARGET_LOCATION="${TARGET_LOCATION:-}"
IMAGE_DEFINITION_NAME="${IMAGE_DEFINITION_NAME:-}"

PUBLISHER="${PUBLISHER:-}"
OFFER="${OFFER:-}"
SKU="${SKU:-}"
OSTYPE="${OSTYPE:-}"
OSSTATE="${OSSTATE:-}"
HYPERVGEN="${HYPERVGEN:-}"

DESCRIPTION="${DESCRIPTION:-}"
EULA="${EULA:-}"
PRIVACY_URI="${PRIVACY_URI:-}"
RELEASE_NOTE_URI="${RELEASE_NOTE_URI:-}"
END_OF_LIFE="${END_OF_LIFE:-}"
TAGS="${TAGS:-}"
PLAN_NAME="${PLAN_NAME:-}"
PLAN_PRODUCT="${PLAN_PRODUCT:-}"
PLAN_PUBLISHER="${PLAN_PUBLISHER:-}"
DISALLOWED_DISK_TYPES="${DISALLOWED_DISK_TYPES:-}"
ARCHITECTURE="${ARCHITECTURE:-}"
FEATURES_LIST="${FEATURES_LIST:-}"
REC_VCPUS_MIN="${REC_VCPUS_MIN:-}"
REC_VCPUS_MAX="${REC_VCPUS_MAX:-}"
REC_MEM_MIN="${REC_MEM_MIN:-}"
REC_MEM_MAX="${REC_MEM_MAX:-}"
ACCELERATED_NETWORKING="${ACCELERATED_NETWORKING:-}"
AUTOMATIC_OS_UPGRADE="${AUTOMATIC_OS_UPGRADE:-}"

ENV_FILE=""
DRY_RUN=false

# -------- First pass to source env file early (so later args override) --------
# We parse manually to detect --env-file before full parse.
for i in "$@"; do
  if [[ "$i" == "--env-file" ]]; then
    # Next token is the file path
    break
  fi
done
# Simple loop to fetch file after --env-file
args=("$@")
for (( idx=0; idx < $#; idx++ )); do
  if [[ "${args[$idx]}" == "--env-file" ]]; then
    next=$((idx+1))
    if (( next >= $# )); then
      echo "ERROR: --env-file requires a value" >&2
      exit 1
    fi
    ENV_FILE="${args[$next]}"
    if [ ! -f "$ENV_FILE" ]; then
      echo "ERROR: env file '$ENV_FILE' not found" >&2
      exit 1
    fi
    # shellcheck disable=SC1090
    . "$ENV_FILE"
    break
  fi
done

# -------- Full Argument Parsing --------
while [[ $# -gt 0 ]]; do
  case "$1" in
    --target-subscription) TARGET_SUBSCRIPTION="$2"; shift 2;;
    --target-rg) TARGET_RG="$2"; shift 2;;
    --target-gallery-name) TARGET_GALLERY_NAME="$2"; shift 2;;
    --target-location) TARGET_LOCATION="$2"; shift 2;;
    --image-definition-name) IMAGE_DEFINITION_NAME="$2"; shift 2;;
    --publisher) PUBLISHER="$2"; shift 2;;
    --offer) OFFER="$2"; shift 2;;
    --sku) SKU="$2"; shift 2;;
    --os-type) OSTYPE="$2"; shift 2;;
    --os-state) OSSTATE="$2"; shift 2;;
    --hyper-v-generation) HYPERVGEN="$2"; shift 2;;
    --description) DESCRIPTION="$2"; shift 2;;
    --eula) EULA="$2"; shift 2;;
    --privacy-uri) PRIVACY_URI="$2"; shift 2;;
    --release-note-uri) RELEASE_NOTE_URI="$2"; shift 2;;
    --end-of-life) END_OF_LIFE="$2"; shift 2;;
    --tags) TAGS="$2"; shift 2;;
    --plan-name) PLAN_NAME="$2"; shift 2;;
    --plan-product) PLAN_PRODUCT="$2"; shift 2;;
    --plan-publisher) PLAN_PUBLISHER="$2"; shift 2;;
    --disallowed-disk-types) DISALLOWED_DISK_TYPES="$2"; shift 2;;
    --architecture) ARCHITECTURE="$2"; shift 2;;
    --features) FEATURES_LIST="$2"; shift 2;;
    --rec-vcpus-min) REC_VCPUS_MIN="$2"; shift 2;;
    --rec-vcpus-max) REC_VCPUS_MAX="$2"; shift 2;;
    --rec-mem-min) REC_MEM_MIN="$2"; shift 2;;
    --rec-mem-max) REC_MEM_MAX="$2"; shift 2;;
    --accelerated-networking) ACCELERATED_NETWORKING="$2"; shift 2;;
    --automatic-os-upgrade) AUTOMATIC_OS_UPGRADE="$2"; shift 2;;
    --env-file) ENV_FILE="$2"; shift 2;; # already sourced earlier; still shift
    --dry-run) DRY_RUN=true; shift 1;;
    -h|--help) show_usage; exit 0;;
    *) echo "Unknown argument: $1" >&2; show_usage; exit 1;;
  esac
done

# Derive generic names (mirror prior behavior)
RESOURCE_GROUP="${RESOURCE_GROUP:-$TARGET_RG}"
GALLERY_NAME="${GALLERY_NAME:-$TARGET_GALLERY_NAME}"
LOCATION="${LOCATION:-$TARGET_LOCATION}"

# -------- Validation --------
required_vars=(TARGET_SUBSCRIPTION TARGET_RG TARGET_GALLERY_NAME TARGET_LOCATION IMAGE_DEFINITION_NAME PUBLISHER OFFER SKU OSTYPE OSSTATE HYPERVGEN)
missing=()
for v in "${required_vars[@]}"; do
  if [ -z "${!v:-}" ]; then
    missing+=("$v")
  fi
done
if [ ${#missing[@]} -gt 0 ]; then
  echo "ERROR: Missing required variables: ${missing[*]}" >&2
  show_usage
  exit 1
fi

# -------- Build az arguments --------
ARGS=(sig image-definition create
  --resource-group "$RESOURCE_GROUP"
  --gallery-name "$GALLERY_NAME"
  --gallery-image-definition "$IMAGE_DEFINITION_NAME"
  --location "$LOCATION"
  --publisher "$PUBLISHER"
  --offer "$OFFER"
  --sku "$SKU"
  --os-type "$OSTYPE"
  --os-state "$OSSTATE"
  --hyper-v-generation "$HYPERVGEN"
)

[ -n "$DESCRIPTION" ]           && ARGS+=(--description "$DESCRIPTION")
[ -n "$EULA" ]                  && ARGS+=(--eula "$EULA")
[ -n "$PRIVACY_URI" ]           && ARGS+=(--privacy-statement-uri "$PRIVACY_URI")
[ -n "$RELEASE_NOTE_URI" ]      && ARGS+=(--release-note-uri "$RELEASE_NOTE_URI")
[ -n "$END_OF_LIFE" ]           && ARGS+=(--end-of-life-date "$END_OF_LIFE")
[ -n "$TAGS" ]                  && ARGS+=(--tags "$TAGS")
[ -n "$PLAN_NAME" ]             && ARGS+=(--plan-name "$PLAN_NAME")
[ -n "$PLAN_PRODUCT" ]          && ARGS+=(--plan-product "$PLAN_PRODUCT")
[ -n "$PLAN_PUBLISHER" ]        && ARGS+=(--plan-publisher "$PLAN_PUBLISHER")
[ -n "$DISALLOWED_DISK_TYPES" ] && ARGS+=(--disallowed-disk-types "$DISALLOWED_DISK_TYPES")
[ -n "$ARCHITECTURE" ]          && ARGS+=(--architecture "$ARCHITECTURE")
[ -n "$FEATURES_LIST" ]         && ARGS+=(--features $FEATURES_LIST)

if [ -n "$REC_VCPUS_MIN" ] || [ -n "$REC_VCPUS_MAX" ]; then
  rec_vcpus=""
  [ -n "$REC_VCPUS_MIN" ] && rec_vcpus+="Min=$REC_VCPUS_MIN"
  [ -n "$REC_VCPUS_MAX" ] && rec_vcpus+=" ${rec_vcpus:+ }Max=$REC_VCPUS_MAX"
  ARGS+=(--recommended-vm-vcpus "$rec_vcpus")
fi
if [ -n "$REC_MEM_MIN" ] || [ -n "$REC_MEM_MAX" ]; then
  rec_mem=""
  [ -n "$REC_MEM_MIN" ] && rec_mem+="Min=$REC_MEM_MIN"
  [ -n "$REC_MEM_MAX" ] && rec_mem+=" ${rec_mem:+ }Max=$REC_MEM_MAX"
  ARGS+=(--recommended-vm-memory "$rec_mem")
fi

case "$ACCELERATED_NETWORKING" in true|false) ARGS+=(--accelerated-networking "$ACCELERATED_NETWORKING");; esac
case "$AUTOMATIC_OS_UPGRADE" in true|false) ARGS+=(--automatic-os-upgrade "$AUTOMATIC_OS_UPGRADE");; esac

echo "Setting Azure subscription to target ${TARGET_SUBSCRIPTION}"
az account set --subscription "$TARGET_SUBSCRIPTION"

# Idempotent check
if az sig image-definition show \
  --resource-group "$RESOURCE_GROUP" \
  --gallery-name "$GALLERY_NAME" \
  --gallery-image-definition "$IMAGE_DEFINITION_NAME" >/dev/null 2>&1; then
  echo "Image definition '${IMAGE_DEFINITION_NAME}' already exists in gallery '${GALLERY_NAME}'. Skipping creation."
  EXISTING_JSON=$(az sig image-definition show \
    --resource-group "$RESOURCE_GROUP" \
    --gallery-name "$GALLERY_NAME" \
    --gallery-image-definition "$IMAGE_DEFINITION_NAME" -o json)
  if [ "${DRY_RUN}" = "true" ]; then
    echo "DRY RUN: Would write existing JSON to \$AZ_SCRIPTS_OUTPUT_PATH"
  else
    if [ -n "${AZ_SCRIPTS_OUTPUT_PATH:-}" ]; then
      echo "$EXISTING_JSON" > "$AZ_SCRIPTS_OUTPUT_PATH"
    else
      echo "$EXISTING_JSON"
    fi
  fi
  exit 0
fi

echo "Executing: az ${ARGS[*]}"
if [ "${DRY_RUN}" = "true" ]; then
  echo "DRY RUN: Skipping actual az execution."
else
  az "${ARGS[@]}"
fi

OUTPUT_JSON=$(az sig image-definition show \
  --subscription "$TARGET_SUBSCRIPTION" \
  --resource-group "$RESOURCE_GROUP" \
  --gallery-name "$GALLERY_NAME" \
  --gallery-image-definition "$IMAGE_DEFINITION_NAME" \
  --query '{name:name, id:id, publisher:publishingProfile.publisher, offer:publishingProfile.offer, sku:publishingProfile.sku, osType:osType}' -o json)

if [ "${DRY_RUN}" = "true" ]; then
  echo "DRY RUN: Would output JSON:"
  echo "$OUTPUT_JSON"
else
  if [ -n "${AZ_SCRIPTS_OUTPUT_PATH:-}" ]; then
    echo "$OUTPUT_JSON" > "$AZ_SCRIPTS_OUTPUT_PATH"
  else
    echo "$OUTPUT_JSON"
  fi
  echo "New image definition '${IMAGE_DEFINITION_NAME}' created (or updated) in gallery '${GALLERY_NAME}'."
fi
